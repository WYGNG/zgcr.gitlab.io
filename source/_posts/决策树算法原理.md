---
title: 决策树算法原理
date: 2019-03-08 12:46:16
tags:
- 机器学习原理推导
categories:
- 机器学习原理推导
mathjax: true
---

# 决策树介绍
决策树中每个根结点（非叶子结点）代表数据的特征标签，根据该特征不同的特征值将数据划分成几个子集，每个子集都是这个根结点的子树，然后对每个子树递归划分下去，而决策树的每个叶子结点则是数据的最终类别标签。对于一个样本特征向量，则从决策树的顶端往下进行分类，直到根结点，得到的类别标签就是这个样本向量的类别。
**决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。**
# 决策树的特征选择准则
特征选择准则有信息增益、信息增益率、基尼指数，相应的决策树称为ID3、C4.5、CART决策树。
## ID3算法
假定当前样本集合D中第k类样本所占的比例为
$$
C_{k}(k=1,2, \ldots,|\mathcal{Y}|)
$$
则全体样本集合D的信息熵定义为:
$$
H(D)=-\sum_{k=1}^{K} \frac{\left|C_{k}\right|}{|D|} \log_{2} (\frac{|C_{k}|}{|D|})
$$

即全体样本集合D的信息熵就是每类样本所占比例乘以log2（每类样本所占比例），最后求和，再取反（保证数据为正值）。

假设根据某个离散特征A的取值可将D划分为n个子集:
$$
(D_{1}, D_{2}, \cdots, D_{n})
$$
子集Di中属于类Ck的样本记为Dik。则特征A对数据集D的经验条件熵为:
$$
H(D | A)=\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} H\left(D_{i}\right)
$$
$$
=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D| } \sum_{k=1}^{K} \frac{\left|D_{i k}\right|}{\left|D_{i}\right|} \log_{2} (\frac{\left|D_{i k}\right|}{|D_{i}|})
$$
即先分别计算按特征取值划分的样本子集Di的信息熵，然后分别乘以每个子集占总集合的比例，最后求和。
ID3算法使用划分前后集合信息熵的差值来衡量使用当前特征对于样本集合D划分效果的好坏。具体来说，就是用全体集合D的信息熵减去特征A对数据集D的经验条件熵，称为信息增益:
$$
g(D, A)=H(D)-H(D | A)
$$
在使用ID3算法划分时，我们总是先分别计算用每一种特征划分数据集D的信息增益，然后从中选择信息增益最大的特征来划分，即使用这个特征划分时数据集D的信息熵下降的最快，数据集D的纯度上升的最快。
当某个特征取值较多时，根据此特征划分更容易得到纯度更高的子集，因此划分之后的熵更低（极端情况下如果特征只有一种取值，那么特征的经验条件熵为0，信息增益就是H（D）。否则经验条件熵是负数，由于前面还有负号，就变成了正数，相当于H（D）加上一个大于0的正数），由于划分前的熵是一定的，因此信息增益更大，因此信息增益偏向取值较多的特征。
计算实例请看西瓜书P75-P77。
## C4.5算法
C4.5算法使用信息增益比来选择划分特征。特征A对训练数据集D的信息增益比定义为其信息增益与特征A对数据集D的经验熵之比:
$$
g_{R}(D, A)=\frac{g(D, A)}{H_{A}(D)}
$$
特征A对数据集D的经验熵HA（D）即将数据集D按特征A的不同子集划分成 V个子集:
$$
(D_{1}, D_{2}, \cdots, D_{v})
$$
 然后按这种划分方式求其信息熵。
$$
H_{A}(D)=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} \log_{2} (\frac{|D_{i}|}{|D|})
$$
当特征取值较少时HA（D）的值较小，因此其倒数较大，因而信息增益比较大。故C4.5算法偏向特征值取值较少的特征。
## CART决策树
CART决策树使用基尼指数来选择划分特征。基尼指数表示在样本集合中一个随机选中的样本被分错的概率。基尼指数越小表示集合中被选中的样本被分错的概率越小，也就是说集合的纯度越高，反之，集合越不纯。即:基尼指数（基尼不纯度）= 样本被选中的概率X样本被分错的概率。
$$
\operatorname{Gini}(\mathrm{p})=\sum_{k=1}^{K} p_{k}\left(1-p_{k}\right)=1-\sum_{k=1}^{K} p_{k}^{2}
$$
pk表示选中的样本属于k类别的概率，则这个样本被分错的概率是(1-pk)。
对于一个样本集合D的基尼指数为:
$$
\operatorname{Gini}(\mathrm{D})=1-\sum_{k=1}^{K}\left(\frac{\left|C_{k}\right|}{|D|}\right)^{2}
$$
即假设集合中有K个类别，对样本集合D的基尼指数为1减去各个类别样本数占总样本数之比的和。
某个特征A按v个不同取值将数据集分为v个子集:
$$
(D_{1}, D_{2}, \cdots, D_{v})
$$
则特征A对数据集合D的基尼指数为:
$$
\operatorname{Gini} \operatorname{index}(D, a)=\sum_{y=1}^{V} \frac{\left|D^{v}\right|}{|D|} \operatorname{Gini}\left(D^{v}\right)
$$
我们总是选择使上面基尼指数值最小的特征A来划分数据集。
# C4.5算法对连续值的处理
对于连续值特征，因为样本集合中的样本数总是有限的，因此我们可以将其看成离散的数据。假设样本数为n，那么对n条数据的特征值进行从小到大排序后，我们可以得到n-1个两两特征值之间的中点作为候选的划分点，注意这个特征点是将这个连续值特征离散化成二值的划分点。然后我们分别计算这些点上的信息增益比，取最大信息增益比的点作为这个连续值特征的离散化二值的划分点即可。
# 常用剪枝方法
决策树常用剪枝方法有两种：预剪枝和后剪枝。
## 预剪枝
预剪枝即在树中结点进行扩展之前，先计算当前的划分是否能带来模型泛化能力的提升（通过在测试集上的准确率进行判断），如果不能，则不再继续生长子树。此时可能存在不同类别的样本同时存于结点中，按照多数投票的原则判断该结点所属类别。
## 后剪枝
后剪枝是让算法生成一棵完全生长的决策树，然后从最底层向上计算是否剪枝。剪枝过程将子树删除，用一个叶子结点替代，该结点的类别同样按照多数投票的原则进行判断。同样地，后剪枝也可以通过在测试集上的准确率进行判断，如果剪枝过后准确率有所提升，则进行剪枝。
# 决策树算法的优点和缺点
**决策树算法的优点：**
* 数据集基本不需要预处理，不需要提前归一化，处理缺失值；
* 既可以处理离散值也可以处理连续值；
* 可以处理多维度输出的分类问题；
* 可以交叉验证剪枝来选择模型，从而提高泛化能力；
* 对于异常点的容错能力好，健壮性高。

**决策树算法的缺点：**
* 容易过拟合，导致泛化能力不强。可以通过设置节点最少样本数量和限制决策树深度来改进；
* 当数据集样本发生一点点改动，就会导致树结构的剧烈改变。这个可以通过集成学习之类的方法解决；
* 寻找最优的决策树是一个NP难的问题，我们一般是通过启发式方法，容易陷入局部最优。可以通过集成学习之类的方法来改善；
* 有些比较复杂的关系，决策树很难学习，比如异或；
* 如果某些特征的样本比例过大，生成决策树容易偏向于这些特征。这个可以通过调节样本权重来改善。

 