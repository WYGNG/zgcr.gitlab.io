---
title: 集成学习Bagging、随机森林、Boosting、Adaboost原理
date: 2019-03-11 22:40:55
tags:
- 机器学习原理推导
categories:
- 机器学习原理推导
mathjax: true
---

# 集成学习介绍
集成学习通过构建并组合一系列的个体学习器（基学习器或组件学习器）来完成学习任务。
个体学习器可分为：同质学习器（基学习器）和异质学习器（组件学习器）。所谓同质和异质就是指个体学习器是否为同种学习算法类型的学习器（同种为同质，不同种为异质）。
弱学习器指泛化性能略优于随机猜测的学习器；强学习器，指泛化性能较好的学习器。我们一般称基学习器或者简单算法的个体学习器为弱学习器。
集成学习，就是对一系列弱学习器进行组合，进而构建出强学习器的一种算法。
**集成学习包括Bagging方法和Boosting方法:**
Bagging:个体学习器之间存在弱依赖关系，可同时生成的并行化方法，如随机森林。
Boosting:个体学习器之间存在强依赖关系，必须串行生成的序列化方法，如 AdaBoost。
# Bagging方法
bagging采取的是自助采样法，即有放回的采样。
**Bagging方法思想:**
使用自助采样法得到一个包含m个样本的采样集。通过k轮抽样，我们能够得到k个训练集（训练集之间相互独立）。 
每次用一个训练集得到一个模型，这样通过k个训练集就能够得到k个模型。 
在做模型预测时，对于分类问题，我们采用简单投票法；对于回归任务用简单平均法，求平均值。

# 随机森林（random forests）
随机森林是Bagging算法的改进版。
首先，随机森林使用了CART决策树作为弱学习器；其次，随机森林对决策树的建立做了改进：对普通的决策树，我们会在节点上所有的n个样本特征中选择一个最优的特征来做决策树的左右子树划分，但是RF通过随机选择节点上的一部分样本特征，这个数字小于n，假设为nsub，然后在这些随机选择的nsub个样本特征中，选择一个最优的特征来做决策树的左右子树划分。这样进一步增强了模型的泛化能力。　
如果nsub=n，则此时随机森林的CART决策树和普通的CART决策树没有区别。nsub越小，则模型约健壮，当然此时对于训练集的拟合程度会变差。在实际案例中，一般会通过交叉验证调参获取一个合适的nsub值。　　
**随机森林算法:**
从原始训练集中进行自主采样，每次采样m个样本，共产生t个训练集，然后用采样集Dt训练第t个决策树；
训练决策树模型节点时，从节点上所有样本特征中随机选取nsub个特征，在这些随机选择的特征中选择一个最优的特征来做决策树的左右子树划分；
预测时，如果是分类预测，则t个弱学习器投出最多票数的类别或者类别之一为最终类别。如果是回归算法，t个弱学习器得到的回归结果进行算术平均得到的值为最终的模型输出。
**随机森林的优点:**
训练可以高度并行化，对于大数据时代的大样本训练速度有优势；
随机选择决策树节点划分特征，在样本特征维度很高的时候，仍然能高效地训练模型；
采用了随机采样，训练出的模型的方差小，泛化能力强；
相对于Boosting系列的Adaboost和GBDT， RF实现比较简单；
对部分特征缺失不敏感。
**随机森林的缺点:**
在某些噪音比较大的样本集上，RF模型容易陷入过拟合；
特征值取值划分比较多的特征容易对RF的决策产生更大的影响，从而影响拟合的模型效果。
# Boosting方法
Boosting方法是采用重赋权法迭代地训练基分类器。即对每一轮的训练数据样本赋予一个权重，并且每一轮样本的权值分布依赖上一轮的分类结果。基分类器之间采用序列式的线性加权方式进行组合。 
Boosting方法通过提高那些在前一轮被弱学习器分错样例的权值，减小前一轮正确样例的权值，使学习器重点学习分错的样本，提高学习器的性能；通过加法模型将弱学习器进行线性组合，学习器准确率大的模型则相应权值大，反之则学习器的权值小。
**Boosting方法思想:**
首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，这些误差率高的训练样本点在后面的弱学习器更容易被选为训练样本。然后基于调整权重后的训练集来训练弱学习器2，如此重复进行，直到弱学习器数达到事先指定的数目t，最终将这t个弱学习器通过集合策略进行整合，得到最终的强学习器。
Boosting系列算法里最著名算法主要有AdaBoost算法和提升树（boosting tree）系列算法。提升树系列算法里面应用最广泛的是梯度提升决策树（Gradient Boosting Decison Tree）。
# Adaboost
Adaboost算法（Adaptive Boosting，自适应增强）是一种典型的Boosting算法。
利用“重赋权法”（re-weighting），即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重。
**Adaboost算法思想:**
首先初始化训练集权重分布,对原始训练集中的每个样本赋予相同的权重，假如训练集有N个样本，那么每个样本的初始权重均为1/N；
其次，循环训练弱分类器。将加有权重的训练集用于训练弱学习器，在训练过程中，如果某个样本能够准确地分类和预测，那么在构造下一个训练集的过程中，就要降低该样本的权重，同时增加无法准确分类或预测的样本的权重。重新确定样本权重后，然后进行下一次弱学习器的训练。如此重复进行，直至基学习器数目达到事先指定的值t或者准确率。
最后，组合生成的多个弱学习器得到强学习器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。

**Adaboost算法详细实现过程:**
假如给出了一个二分类训练数据集:
$$
T=((x_{1}, y_{1}),(x_{2}, y_{2}), \cdots,(x_{n}, y_{n}))
$$
yi取值为1或-1。
首先将训练集中每一个样本赋予相同的权重，即1/N:
$$
D_{1}=(w_{11}, w_{12}, \cdots, w_{1 i}, \cdots, w_{1 N})
$$
$$
w_{1 i}=\frac{1}{N}, i=1,2, \cdots, N
$$
下面我们要迭代训练基学习器。
用m表示迭代轮数，其中
$$
m=1,2,3, \cdots, M
$$
使用具有权值分布Dm的训练数据集学习，得到基本分类器
$$
G_{m}(x) : \chi \rightarrow\{-1,+1\}
$$
计算得到的基分类器Gm(x)在训练数据集上的分类误差率em
$$
e_{m}=P\left(G_{m}(x) \neq y_{i}\right)=\frac{\sum_{i=1}^{N} w_{m i} I\left(G_{m}\left(x_{i}\right) \neq y_{i}\right)}{\sum_{i=1}^{N} w_{m i}}=\sum_{i=1}^{N} w_{m}
$$
其中wmi表示第m轮中第i个样本的权重。
$$
\sum_{i=1}^{N} w_{m i}=1
$$
下面这个函数指示了预测分类和真实标签是否相同，不同时为1，相同时为0。
$$
I\left(G_{m}\left(x_{i}\right) \neq y_{i}\right)
$$
显然Gm(x)在加权的训练数据集上的分类误差率em是被Gm(x)误分类样本的权值之和。
计算Gm前面的权重系数am，该系数表示Gm在最终分类器中的重要程度 ,目的在于使我们得到基分类器在最终分类器中所占的权值:
$$
\alpha_{m}=\frac{1}{2} \ln \frac{1-e_{m}}{e_{m}}
$$
当em小于1/2时，am随着em的减小而增大，意味着分类误差越小的基本分类器在最终分类器的作用越大。em大于1/2时刚好相反。这正好验证了集成学习中每个个体分类器的分类精度必须大于0.5的前提条件。
更新训练数据集的权值分布（目的：得到样本的新的权值分布），用于下一轮迭代。
$$
D_{m+1}=\left(w_{m+1,1}, w_{m+1,2}, \cdots, w_{m+1, i}, \cdots, w_{m+1, N}\right)
$$
其中:
$$
w_{m+1, i}=\frac{w_{m i}}{Z_{m}} \exp \left(-\alpha_{m} y_{i} G_{m}\left(x_{i}\right)\right), i=1,2, \cdots, N
$$
Zm是我们引入的一个规范化因子，它的作用在于使Dm+1成为一个概率分布:
$$
Z_{m}=\sum_{i=1}^{N} w_{m i} \exp \left(-\alpha_{m} y_{i} G_{m}\left(x_{i}\right)\right), i=1,2, \cdots, N
$$
由于是二分类，上式可进一步简化为（yi只能取-1和+1两个值）:
$$
w_{m+1, i}=\begin{cases}{\frac{w_{m i}}{Z_{m}} e^{-\alpha_{m}},} & {G_{m}\left(x_{i}\right)=y_{i}} \\\\ {\frac{w_{m i}}{Z_{m}} e^{\alpha_{m}},} & {G_{m}(x i) \neq y_{i}}\end{cases}
$$
由上式，显然被基本分类器Gm(x)误分类样本的权值得以扩大，而被正确分类样本的权值得以缩小，误分类样本在下一轮学习中起更大的作用。不改变所给的训练数据，而不断改变训练数据权值的分布，使得训练数据在基本分类器的学习中起不同的作用，这是AdaBoost的一个特点。
重复上面步骤（从取Dm训练集开始到上面为止），得到一系列的权重参数am和基分类器Gm。
下面我们要根据权重参数线性组合各个基学习器。借助sign函数，将f（x）的连续值转化为离散值，故最终的分类器为：
$$
G(x)=sign(f(x))=sign\left(\sum_{m=1}^{M} \alpha_{m} G_{m}(x)\right)
$$
线性组合f(x)实现了M个基本分类器的加权表决。系数am表示了基本分类器Gm(x)的重要性，这里所有的am之和并不为1。f(x)的符号决定实例x的类，f(x)的绝对值表示分类的确信度，利用基本分类器的线性组合构建最终分类器是AdaBoost的另一特点。
# 集成学习的结合策略
在最终预测问题时，集成学习有下面几种结合策略:
对于数值类的回归预测问题，通常使用的结合策略是平均法，也就是说，对于若干个弱学习器的输出进行平均得到最终的预测输出；
对于分类问题的预测，我们通常使用的是多数投票法；
还有一种学习法，代表方法是stacking，即我们不是对弱学习器的结果做简单的逻辑处理，而是再加上一层学习器，将训练集弱学习器的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终结果。这种情况下，我们将弱学习器称为初级学习器，将用于结合的学习器称为次级学习器。对于测试集，我们首先用初级学习器预测一次，得到次级学习器的输入样本，再用次级学习器预测一次，得到最终的预测结果。

**下面是决策树与这些算法框架进行结合所得到的新的算法:**
* Bagging + 决策树 = 随机森林 
* AdaBoost + 决策树 = 提升树 
* Gradient Boosting + 决策树 = GBDT