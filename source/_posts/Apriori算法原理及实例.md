---
title: Apriori算法原理及实例
date: 2019-04-03 23:36:29
tags:
- 机器学习原理推导
categories:
- 机器学习原理推导
mathjax: true
---


# 关联分析:频繁项集和关联规则
从大规模的数据中发现物品间隐含关系的方法被称为关联分析。关联分析是一种在大规模数据集中寻找有趣关系的任务。
**这些任务有两种形式:频繁项集和关联规则。**
频繁项集是经常出现在一块的物品的集合；
关联规则暗示的是两种物品之间可能存在很强的关系。

比如著名的“啤酒与尿布”的例子中，（啤酒，尿布）就是频繁项集中的一个例子。

**常用的频繁项集的评估标准有支持度、置信度、提升度:**
* 支持度就是几个关联的数据在数据集中出现的次数占总数据集的比重。一般来说，支持度高的数据不一定构成频繁项集，但是支持度太低的数据肯定不构成频繁项集。如果我们有两个想分析关联性的数据X和Y，则对应的支持度为:
$$
(X, Y)=P(X Y)=\frac{\text {number }(X Y)}{\text {num(AllSamples)}}
$$
* 置信度体现了一个数据出现后，另一个数据出现的概率，或者说数据的条件概率。如果我们有两个想分析关联性的数据X和Y，X对Y的置信度为:
$$
(X \Leftarrow Y)=P(X | Y)=\frac{P(X Y)}{P(Y)}
$$
* 提升度即在含有Y的条件下，同时含有X的概率，与X总体发生的概率之比。提升度>1且越高表明正相关性越高；提升度<1且越低表明负相关性越高；提升度=1表明没有相关性。
$$
Lift(X \Leftarrow Y)=\frac{P(X | Y)}{P(X)}=\frac{\text { Confidence }(X \Leftarrow Y)}{ P(X)}
$$

**举例:**
10000个超市订单（10000个事务），其中购买A牛奶（A事务）6000个，购买B牛奶（B事务）7500个，4000个同时包含两者。
那么A牛奶（A事务）和B牛奶（B事务）的支持度为:
P（A&B）=4000/10000=0.4
A牛奶（A事务）对B牛奶（B事务）的置信度为包含A的事务中同时包含B的占包含A的事务比例:
4000/6000=0.67
说明在购买A牛奶后，有0.67的用户去购买B牛奶。
伊利牛奶（B事务）B牛奶对A牛奶（A事务）的置信度为包含B的事务中同时包含A的占包含B的事务比例:
4000/7500=0.53
说明在购买A牛奶后，有0.53的用户去购买B牛奶。
这里有一点要注意，就是没有任何条件下时，B事务的出现的比例是0.75，而出现A事务，且同时出现B事务的比例是0.67，也就是说设置了A事务出现这个条件，B事务出现的比例反而降低了。这说明A事务和B事务是排斥的。
我们计算A事务对B事务的提升度:
P（B|A）/P（B）=0.67/0.75
显然提升度<1，说明A和B是负相关的。

商品列表中，可能存在单一商品组成的频繁项集，也可能存在两个以及两个以上的商品组成的频繁项集。在计算一个频繁项集的支持度时，通常需要遍历所有的商品列表求得，但当列表数目成千上万时，计算量过大，这种方法显然不适用。这时候我们就要用Apriori算法了。
# Apriori算法原理
Apriori算法的原理就是如果某个项集是频繁的，那么它的所有子集也是频繁的。同时它的逆否命题也成立:如果一个项集是非频繁集，那么它的所有超集也是非频繁的。
Apriori算法的两个输入参数分别是最小支持度和数据集，该算法首先会生成所有单个物品的项集列表，接着扫描交易记录来查看哪些项集满足最小支持度要求，那些不满足最小支持度的集合会被去掉。然后，对生下来的集合进行组合以生成包含两个元素的项集，接下来，再重新扫描交易记录，去掉不满足最小支持度的项集。该过程重复进行，直到所有项集都被去掉。
**举例:**
假设一个集合{A,B}是频繁项集，即A、B同时出现在一条记录的次数大于等于最小支持度min_support，则它的子集{A},{B}出现次数必定大于等于min_support，即它的子集都是频繁项集。
假设集合{A}不是频繁项集，即A出现的次数小于min_support，则它的任何超集如{A,B}出现的次数必定小于min_support，因此其超集必定也不是频繁项集。

**Apriori算法步骤:**
* 先计算1项集的支持度，筛选出频繁1项集；
* 然后排列组合出2项集，计算出2项集的支持度，筛选出频繁2项集；
* 然后通过连接和剪枝计算出3项集，计算出3项集的支持度，筛选出频繁3项集；
* 然后依次类推处理K项集，直到没有频繁集出现。 

**如何从K-1项集计算出K项集（K>=3，K=2时用组合公式C（2,n）即可）？**
连接:对K-1项集中的每个项集中的项排序，只有在前K-1项相同时才将这两项合并，形成候选K项集（因为必须形成K项集，所以只有在前K-1项相同，第K项不相同的情况下才合并。） 
剪枝:对于候选K项集，要验证所有项集的所有K-1子集是否频繁（是否在K-1项集中），去掉不满足的项集，就形成了K项集。

